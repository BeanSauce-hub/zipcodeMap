<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <title>Florida ZIP Volume Map (Local GeoJSON + Daily Trend + Focus Highlight)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; }

    .legend { background: white; padding: 10px 12px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,.12); line-height: 1.4; font-size:12px; }
    .info { padding: 8px 10px; background: white; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,.12); font-size:12px; }

    .panel {
      position: absolute; z-index: 1000; left: 12px; top: 12px;
      background: rgba(255,255,255,.95); padding: 12px 14px; border-radius: 14px;
      box-shadow: 0 2px 14px rgba(0,0,0,.10);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, 'Noto Sans', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif;
      min-width: 340px;
    }
    .panel h1 { font-size: 20px; margin: 0 0 10px; }
    .panel .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:8px; }
    .btn {
      display:inline-block; padding:7px 12px; border-radius:10px; background:#111; color:#fff;
      text-decoration:none; cursor:pointer; font-size:12px; user-select:none;
    }
    .btn.ghost { background:#fff; color:#111; border:1px solid #ddd; }
    .input { padding:7px 10px; border-radius:10px; border:1px solid #ddd; font-size:13px; }
    select{ padding:6px 10px; border-radius:10px; border:1px solid #ddd; background:#fff; }
    .toggle { display:flex; align-items:center; gap:8px; font-size:12px; }
    .hint{font-size:12px;color:#666;margin-top:10px;line-height:1.35;}

    .drop {
      position:absolute; z-index:999; left:50%; top:50%; transform:translate(-50%,-50%);
      width:min(720px,90vw); padding:18px; border:2px dashed #888; border-radius:12px;
      background:rgba(255,255,255,.96); display:none; text-align:center;
    }
    .drop h2{margin:0 0 6px;font-size:18px;}
    .drop p{margin:4px 0;font-size:13px;color:#555;}

    .flash { animation: flash 1s ease-in-out 3; }
    @keyframes flash {
      0% { filter: drop-shadow(0 0 0 rgba(255,0,0,0)); }
      50% { filter: drop-shadow(0 0 10px rgba(255,0,0,.85)); }
      100% { filter: drop-shadow(0 0 0 rgba(255,0,0,0)); }
    }

    /* sparkline */
    .sparkline { margin-top:8px; }
    .sparkline text { font-size:10px; fill:#555; }

    /* tooltip overflow safety */
    .leaflet-tooltip,
    .leaflet-tooltip .leaflet-tooltip-content,
    .sparkline { overflow: visible; }
  </style>
</head>
<body>
  <div class="panel">
    <h1>Florida ZIP Volume Map</h1>

    <div class="row">
      <label style="display:flex;align-items:center;gap:8px;">
        Date:
        <select id="dateSel"></select>
      </label>

      <a class="btn ghost" id="range1w">1W</a>
      <a class="btn ghost" id="range1m">1M</a>
      <a class="btn ghost" id="rangeMax">MAX</a>
    </div>

    <div class="row">
      <input class="input" id="searchZip" placeholder="ZIP (prefix or full)" maxlength="5" style="width:160px;" />
      <a class="btn" id="doSearch">Search</a>
      <a class="btn" id="exportCsv">Export daily CSV</a>
    </div>

    <div class="row">
      <label style="display:flex;align-items:center;gap:8px;">
        Threshold highlight:
        <input class="input" style="width:120px" id="threshold" type="number" placeholder=">= value" />
      </label>
      <label class="toggle"><input type="checkbox" id="thresholdOn" /> Enable</label>
    </div>

    <div class="row">
      <a class="btn ghost" id="pickDailyCsv">Import daily CSV(s)</a>
      <a class="btn ghost" id="pickGeo">Import GeoJSON</a>
      <a class="btn ghost" id="clearFocusBtn">Clear focus</a>
    </div>

    <div class="hint">
      Put <code>fl_florida_zip_codes_geo.min.json</code> next to <code>index.html</code> to auto-load,
      or click “Import GeoJSON”. CSV columns: <b>Zipcodes</b> + (<b>Quantity</b>/<b>pred_quantity</b>/<b>货量</b>/<b>数量</b>) and a date column (or date in filename).
    </div>
  </div>

  <div id="map"></div>

  <div class="drop" id="drop">
    <h2>Drop CSV or GeoJSON here</h2>
    <p>Supports multiple CSVs (different dates) and one GeoJSON.</p>
  </div>

  <input type="file" id="csvPicker" multiple accept=".csv" style="display:none" />
  <input type="file" id="geoPicker" accept=".json,.geojson" style="display:none" />

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    // -------------------- Utils --------------------
    function fmt(n){ return (Math.round((Number(n)||0)*100)/100).toLocaleString(); }
    function normZip(z){
      let s = String(z ?? '').trim();
      if (s.endsWith('.0')) s = s.slice(0,-2);
      s = s.replace(/\D/g,'');
      if (s.length > 5) s = s.slice(0,5);
      return s.padStart(5,'0');
    }
    function downloadText(filename, text){
      const blob = new Blob([text], {type:'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
      URL.revokeObjectURL(url);
    }
    function parseCsv(text){
      const out = Papa.parse(text, { header: true, skipEmptyLines: true, dynamicTyping: false });
      const rows = out.data.map(r=>{
        const obj = {};
        Object.keys(r).forEach(k=> obj[(k||'').trim()] = String(r[k] ?? '').trim());
        return obj;
      });
      const headers = out.meta.fields || [];
      return { headers, rows };
    }

    // Try find date column or infer from filename
    function inferDateFromFilename(name){
      // match YYYY-MM-DD
      const m = name.match(/(20\d{2})[-_\.](\d{2})[-_\.](\d{2})/);
      if (m) return `${m[1]}-${m[2]}-${m[3]}`;
      return null;
    }
    function findDateKey(headers){
      const lower = headers.map(h => (h||'').trim().toLowerCase());
      const cand = ['date','day','ds','order_date','ship_date','delivery_date'];
      for (const c of cand){
        const idx = lower.indexOf(c);
        if (idx !== -1) return headers[idx];
      }
      // fuzzy includes
      for (let i=0;i<lower.length;i++){
        if (lower[i].includes('date')) return headers[i];
      }
      return null;
    }
    function normalizeDateStr(s){
      const t = String(s||'').trim();
      // accept YYYY-MM-DD or YYYY/MM/DD
      const m = t.match(/(20\d{2})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})/);
      if (!m) return null;
      const mm = String(m[2]).padStart(2,'0');
      const dd = String(m[3]).padStart(2,'0');
      return `${m[1]}-${mm}-${dd}`;
    }

    // -------------------- App state --------------------
    // daily[date][zip] = value
    const daily = {}; // { '2025-09-25': { '33143': 193, ... } }
    const breaksByDate = {}; // date -> [q20,q40,q60,q80]
    let geoLayer = null;
    const layerByZip = {};
    let focusedZip = null;
    let focusWired = false;

    // -------------------- Map --------------------
    const map = L.map('map').setView([27.8, -81.7], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom: 12, attribution: '&copy; OpenStreetMap'}).addTo(map);
    map.zoomControl.setPosition('bottomleft');

    const legend = L.control({position:'bottomright'});
    legend.onAdd = function(){ this._div = L.DomUtil.create('div','legend'); this.update(); return this._div; };
    legend.update = function(){
      const d = dateSel.value;
      const b = breaksByDate[d] || [0,0,0,0];
      const colors = ['#ffffcc','#ffeda0','#feb24c','#fd8d3c','#e31a1c'];
      const labels = [
        `${fmt(0)} – ${fmt(b[0])}`,
        `${fmt(b[0])} – ${fmt(b[1])}`,
        `${fmt(b[1])} – ${fmt(b[2])}`,
        `${fmt(b[2])} – ${fmt(b[3])}`,
        `>${fmt(b[3])}`
      ];
      let html = '<b>Color Legend</b><br/>';
      for (let i=0;i<labels.length;i++){
        html += `<i style="background:${colors[i]};width:14px;height:14px;display:inline-block;margin-right:6px;border:1px solid #999"></i>${labels[i]}<br/>`;
      }
      this._div.innerHTML = html;
    };
    legend.addTo(map);

    const info = L.control({position:'topright'});
    info.onAdd = function(){ this._div = L.DomUtil.create('div','info'); this.update(); return this._div; };
    info.update = function(props){
      if (!props) { this._div.innerHTML = 'Hover a ZIP area'; return; }
      const zip = props.zip;
      const d = dateSel.value;
      this._div.innerHTML = buildTooltipHTML(zip, d);
    };
    info.addTo(map);

    // -------------------- UI elements --------------------
    const csvPicker = document.getElementById('csvPicker');
    const geoPicker = document.getElementById('geoPicker');
    const pickDailyCsv = document.getElementById('pickDailyCsv');
    const pickGeo = document.getElementById('pickGeo');
    const clearFocusBtn = document.getElementById('clearFocusBtn');
    const drop = document.getElementById('drop');

    const searchInput = document.getElementById('searchZip');
    const doSearch = document.getElementById('doSearch');
    const exportCsv = document.getElementById('exportCsv');

    const thresholdOn = document.getElementById('thresholdOn');
    const thresholdInput = document.getElementById('threshold');

    const dateSel = document.getElementById('dateSel');
    const range1w = document.getElementById('range1w');
    const range1m = document.getElementById('range1m');
    const rangeMax = document.getElementById('rangeMax');

    // -------------------- Color + Style --------------------
    function getZipFromFeature(f){
      return (f.properties.ZCTA5CE10 || f.properties.ZCTA5CE || f.properties.zip || '').toString().padStart(5,'0');
    }
    function getColor(d, b) {
      if (d == null) return '#f2f2f2';
      if (d <= b[0]) return '#ffffcc';
      if (d <= b[1]) return '#ffeda0';
      if (d <= b[2]) return '#feb24c';
      if (d <= b[3]) return '#fd8d3c';
      return '#e31a1c';
    }
    function overThreshold(val){
      if (!thresholdOn.checked) return false;
      const t = Number(thresholdInput.value);
      if (!isFinite(t)) return false;
      return (Number(val)||0) >= t;
    }
    function styleFeature(feature){
      const z = getZipFromFeature(feature);
      const d = dateSel.value;
      const val = daily[d]?.[z] ?? null;
      const b = breaksByDate[d] || [0,0,0,0];
      const base = { weight: 0.7, opacity: 1, color: '#555', fillOpacity: 0.82, fillColor: getColor(val, b) };
      if (overThreshold(val)) { base.color = '#111'; base.weight = 2.0; }
      return base;
    }

    // -------------------- Sparkline --------------------
    function getAllDatesSorted(){
      return Object.keys(daily).sort();
    }
    function computeBreaks(values){
      const vals = values.filter(v => v>0 && isFinite(v)).sort((a,b)=>a-b);
      if (!vals.length) return [0,0,0,0];
      const q = p => vals[Math.floor(p*(vals.length-1))];
      return [q(.2), q(.4), q(.6), q(.8)];
    }
    function updateBreaksForDate(date){
      const vals = Object.values(daily[date] || {}).map(v => +v || 0);
      breaksByDate[date] = computeBreaks(vals);
    }

    function buildSparklineSVG(zip, currentDate) {
      const dates = getAllDatesSorted();
      if (dates.length < 2) return "";

      const W = 250, H = 90;
      const GUTTER_LEFT = 52;
      const PAD_X = 12, PAD_Y = 18;

      const plotX0 = GUTTER_LEFT + PAD_X;
      const plotX1 = W - PAD_X;
      const plotW  = plotX1 - plotX0;

      // optional range filter (1W / 1M / MAX)
      const range = window.__rangeMode || 'MAX';
      let useDates = dates;
      if (range === '1W' && dates.length > 7) useDates = dates.slice(-7);
      if (range === '1M' && dates.length > 30) useDates = dates.slice(-30);

      const xs = useDates.map((_, i) => plotX0 + i * (plotW) / Math.max(1, (useDates.length - 1)));
      const vals = useDates.map(d => {
        const v = daily[d]?.[zip];
        return (v == null || Number.isNaN(v)) ? null : Number(v);
      });
      const valid = vals.filter(v => v != null);
      if (valid.length < 2) return "";

      const minV = Math.min(...valid), maxV = Math.max(...valid);
      const span = (maxV - minV) || 1;
      const yScale = v => H - PAD_Y - ((v - minV) / span) * (H - 2 * PAD_Y);

      const points = vals.map((v,i) => v==null ? null : ({ x: xs[i], y: yScale(v), d: useDates[i], v }));

      let dpath = "";
      for (let i=0;i<points.length;i++){
        const p = points[i]; if (!p) continue;
        if (i===0 || !points[i-1]) dpath += `M ${p.x} ${p.y}`; else dpath += ` L ${p.x} ${p.y}`;
      }

      const dots = points.map(p=>{
        if (!p) return "";
        const isCur = (p.d === currentDate);
        const r = isCur ? 4 : 2.5;
        const stroke = isCur ? "#111" : "#666";
        const fill = isCur ? "#ffd966" : "#fff";
        return `<circle cx="${p.x}" cy="${p.y}" r="${r}" fill="${fill}" stroke="${stroke}" stroke-width="1.2"/>`;
      }).join("");

      const xAxisY = H - PAD_Y;

      // x labels: show only day-of-month for compact view
      const xLabels = useDates.map((d, i) => {
        const day = d.slice(-2).replace(/^0/,'');
        // thin labels: show every ~5 points if many
        const step = useDates.length > 12 ? Math.ceil(useDates.length/6) : 1;
        if (i % step !== 0 && i !== useDates.length-1) return '';
        return `<text x="${xs[i]}" y="${H-4}" text-anchor="middle" font-size="10" fill="#555">${day}</text>`;
      }).join("");

      const minY = yScale(minV), maxY = yScale(maxV);
      const yGuides = `
        <line x1="${plotX0}" y1="${maxY}" x2="${plotX1}" y2="${maxY}" stroke="#eee"/>
        <line x1="${plotX0}" y1="${minY}" x2="${plotX1}" y2="${minY}" stroke="#eee"/>
        <text x="${GUTTER_LEFT - 6}" y="${maxY + 3}" text-anchor="end" font-size="10"
              style="paint-order: stroke; stroke: #fff; stroke-width: 3px;" fill="#666">${fmt(maxV)}</text>
        <text x="${GUTTER_LEFT - 6}" y="${minY + 3}" text-anchor="end" font-size="10"
              style="paint-order: stroke; stroke: #fff; stroke-width: 3px;" fill="#666">${fmt(minV)}</text>
      `;

      return `
        <div class="sparkline">
          <svg width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
            <line x1="${plotX0}" y1="${xAxisY}" x2="${plotX1}" y2="${xAxisY}" stroke="#ccc"/>
            ${yGuides}
            <path d="${dpath}" fill="none" stroke="#d62728" stroke-width="2"/>
            ${dots}
            ${xLabels}
          </svg>
        </div>
      `;
    }

    function buildTooltipHTML(zip, currentDate){
      const v = daily[currentDate]?.[zip];
      const val = (v==null) ? '—' : fmt(v);
      return `
        <div style="display:flex;justify-content:space-between;align-items:flex-end;gap:10px;">
          <div>
            <div><b>ZIP:</b> ${zip}</div>
            <div style="margin-top:4px;"><b>${currentDate}:</b> <span style="font-weight:700;background:rgba(255,230,150,.6);border-radius:4px;padding:0 4px;">${val}</span></div>
          </div>
        </div>
        ${buildSparklineSVG(zip, currentDate)}
      `;
    }

    // -------------------- Geo rendering --------------------
    function renderGeo(geojson){
      if (geoLayer) map.removeLayer(geoLayer);
      Object.keys(layerByZip).forEach(k => delete layerByZip[k]);

      geoLayer = L.geoJSON(geojson, {
        style: styleFeature,
        onEachFeature: (feature, layer) => {
          const z = getZipFromFeature(feature);
          layerByZip[z] = layer;

          layer.on({
            mouseover: (e)=> {
              const lyr = e.target;
              lyr.setStyle({weight: 2.5, color:'#000', fillOpacity:0.9});
              lyr.bringToFront();
              info.update({ zip: z });
            },
            mouseout: (e)=> {
              if (!geoLayer) return;
              // restore base style, then re-apply focus if exists
              geoLayer.resetStyle(e.target);
              if (focusedZip) applyFocusStyles();
            },
            click: (e)=> {
              info.update({ zip: z });
            }
          });

          layer.bindTooltip(() => buildTooltipHTML(z, dateSel.value), { sticky: true });
        }
      }).addTo(map);

      map.fitBounds(geoLayer.getBounds());

      // wire clear focus on background click (only once)
      if (!focusWired) {
        focusWired = true;
        map.on('click', (e) => {
          const t = e.originalEvent?.target;
          const clickedOnPath = t && (t.tagName === 'PATH' || t.tagName === 'path');
          if (!clickedOnPath) clearFocus();
        });
      }

      refreshMap();
    }

    // -------------------- Focus highlight logic --------------------
    function applyFocusStyles(){
      if (!geoLayer || !focusedZip) return;
      geoLayer.eachLayer(l => {
        const z = getZipFromFeature(l.feature);
        const isTarget = (z === focusedZip);

        if (isTarget) {
          l.setStyle({
            opacity: 1,
            fillOpacity: 0.95,
            weight: 3,
            color: '#000'
          });
          l.bringToFront();
          const el = l.getElement();
          if (el) { el.classList.add('flash'); setTimeout(()=> el.classList.remove('flash'), 1800); }
        } else {
          l.setStyle({
            opacity: 0.20,
            fillOpacity: 0.12,
            weight: 0.7,
            color: '#777'
          });
        }
      });
    }

    function clearFocus(){
      focusedZip = null;
      if (!geoLayer) return;
      geoLayer.setStyle(styleFeature);
    }

    // -------------------- Data loading (daily CSV) --------------------
    function mergeDailyRows(rows, headers, fileName){
      // detect zip key
      const lower = headers.map(h => (h||'').trim().toLowerCase());
      let zipKey = null;
      for (const a of ['zipcodes','zip','zipcode','zip_code']){
        const idx = lower.indexOf(a);
        if (idx !== -1){ zipKey = headers[idx]; break; }
      }
      if (!zipKey) throw new Error('Missing ZIP column (Zipcodes/ZIP/Zip/Zip_Code)');

      // detect value key
      let valKey = null;
      for (const a of ['pred_quantity','quantity','数量','货量','volume','count']){
        const idx = lower.indexOf(a);
        if (idx !== -1){ valKey = headers[idx]; break; }
      }
      if (!valKey) throw new Error('Missing value column (Quantity/pred_quantity/货量/数量)');

      // date
      const dateKey = findDateKey(headers);
      const fileDate = inferDateFromFilename(fileName);

      rows.forEach(r=>{
        const z = normZip(r[zipKey]);
        if (!z || z === '00000') return;

        const v = Number(String(r[valKey] ?? '').replace(/,/g,'')) || 0;

        let d = null;
        if (dateKey) d = normalizeDateStr(r[dateKey]);
        if (!d && fileDate) d = fileDate;

        if (!d) return; // can't place without date
        daily[d] ||= {};
        daily[d][z] = v; // overwrite same (date,zip)
      });
    }

    function rebuildDateSelector(){
      const dates = getAllDatesSorted();
      dateSel.innerHTML = '';
      dates.forEach(d=>{
        const opt = document.createElement('option');
        opt.value = d;
        opt.textContent = d;
        dateSel.appendChild(opt);
      });
      if (dates.length) dateSel.value = dates[dates.length - 1];
    }

    // -------------------- Refresh map --------------------
    function refreshMap(){
      const d = dateSel.value;
      if (d) updateBreaksForDate(d);
      if (geoLayer) geoLayer.setStyle(styleFeature);
      legend.update();
      if (focusedZip) applyFocusStyles(); // keep focus after restyle
    }

    // -------------------- UI events --------------------
    pickDailyCsv.addEventListener('click', ()=> csvPicker.click());
    csvPicker.addEventListener('change', e => handleFiles(e.target.files));

    pickGeo.addEventListener('click', ()=> geoPicker.click());
    geoPicker.addEventListener('change', e=>{
      const f = e.target.files[0]; if (!f) return;
      const fr = new FileReader();
      fr.onload = ()=>{ try{ renderGeo(JSON.parse(fr.result)); }catch(err){ alert('GeoJSON parse failed: ' + err); } };
      fr.readAsText(f);
    });

    clearFocusBtn.addEventListener('click', clearFocus);

    doSearch.addEventListener('click', ()=> focusZip(searchInput.value));
    searchInput.addEventListener('keydown', e=>{ if (e.key === 'Enter') focusZip(searchInput.value); });

    function focusZip(query){
      if (!geoLayer) { alert('Load GeoJSON first.'); return; }
      const q = (query||'').trim();
      if (!q) return;
      const target = Object.keys(layerByZip).find(z => z.startsWith(q));
      if (!target) { alert('ZIP not found in GeoJSON.'); return; }

      focusedZip = target;
      applyFocusStyles();

      const layer = layerByZip[target];
      map.fitBounds(layer.getBounds(), {maxZoom: 11});
      layer.openTooltip();
      info.update({ zip: target });
    }

    exportCsv.addEventListener('click', ()=>{
      const dates = getAllDatesSorted();
      const zips = new Set();
      dates.forEach(d => Object.keys(daily[d]||{}).forEach(z=>zips.add(z)));
      const zipList = Array.from(zips).sort();
      const lines = ['date,zip,quantity'];
      dates.forEach(d=>{
        zipList.forEach(z=>{
          const v = daily[d]?.[z];
          if (v == null) return;
          lines.push(`${d},${z},${v}`);
        });
      });
      downloadText('daily_export.csv', lines.join('\n'));
    });

    thresholdOn.addEventListener('change', refreshMap);
    thresholdInput.addEventListener('change', refreshMap);
    dateSel.addEventListener('change', ()=>{
      refreshMap();
      // update open tooltip content live
      if (focusedZip && layerByZip[focusedZip]) {
        info.update({ zip: focusedZip });
      }
    });

    range1w.addEventListener('click', ()=> { window.__rangeMode='1W'; range1w.classList.remove('ghost'); refreshMap(); if (focusedZip) info.update({zip:focusedZip}); });
    range1m.addEventListener('click', ()=> { window.__rangeMode='1M'; refreshMap(); if (focusedZip) info.update({zip:focusedZip}); });
    rangeMax.addEventListener('click', ()=> { window.__rangeMode='MAX'; refreshMap(); if (focusedZip) info.update({zip:focusedZip}); });

    // drag drop
    ['dragenter','dragover'].forEach(evt=>document.addEventListener(evt, e=>{
      e.preventDefault(); e.stopPropagation(); drop.style.display='block';
    }));
    ['dragleave','drop'].forEach(evt=>drop.addEventListener(evt, e=>{
      e.preventDefault(); e.stopPropagation();
    }));
    drop.addEventListener('drop', e=>{
      handleFiles(e.dataTransfer.files);
      drop.style.display='none';
    });

    function handleFiles(fileList){
      const arr = Array.from(fileList);
      arr.forEach(file=>{
        const name = file.name.toLowerCase();
        const fr = new FileReader();
        fr.onload = ()=>{
          if (name.endsWith('.csv')){
            try{
              const {headers, rows} = parseCsv(fr.result);
              mergeDailyRows(rows, headers, file.name);
              rebuildDateSelector();
              // refresh breaks for current date
              refreshMap();
            }catch(err){
              alert('CSV load failed: ' + err.message);
            }
          } else if (name.endsWith('.json') || name.endsWith('.geojson')){
            try{ renderGeo(JSON.parse(fr.result)); }catch(err){ alert('GeoJSON parse failed: ' + err); }
          }
        };
        fr.readAsText(file);
      });
    }

    // -------------------- Auto-load local GeoJSON if present --------------------
    (async function autoLoadLocalGeo(){
      const url = './fl_florida_zip_codes_geo.min.json';
      try {
        const r = await fetch(url, {cache:'no-store'});
        if (!r.ok) throw new Error('HTTP ' + r.status);
        const gj = await r.json();
        renderGeo(gj);
        console.log('[GeoJSON] loaded:', url);
      } catch (e) {
        console.warn('[GeoJSON] auto-load failed:', e);
      }
    })();

    // Init default range
    window.__rangeMode = 'MAX';
  </script>
</body>
</html>
