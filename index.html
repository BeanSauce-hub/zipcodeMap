<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Florida ZIP Volume Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .legend { background: white; padding: 8px 10px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,.12); line-height: 1.4; font-size:12px; }
    .info { padding: 6px 8px; background: white; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,.12); line-height: 1.4; font-size:12px; }
    .panel {
      position: absolute; z-index: 1000; left: 10px; top: 10px;
      background: rgba(255,255,255,.94); padding: 10px 12px; border-radius: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, 'Noto Sans', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif;
      max-width: 540px;
    }
    .panel h1 { font-size: 18px; margin: 0 0 6px; }
    .panel .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px; }
    .btn { display:inline-block; padding:6px 10px; border-radius:8px; background:#111; color:#fff; text-decoration:none; cursor:pointer; font-size:12px; user-select:none; }
    .input { padding:6px 8px; border-radius:8px; border:1px solid #ddd; font-size:13px; }
    select{ padding:4px 8px; border-radius:8px; }
    .hint{font-size:12px;color:#666;margin-top:6px;}
    .flash { animation: flash 1s ease-in-out 3; }
    @keyframes flash { 0% { filter: drop-shadow(0 0 0 rgba(255,0,0,0)); } 50% { filter: drop-shadow(0 0 8px rgba(255,0,0,.9)); } 100% { filter: drop-shadow(0 0 0 rgba(255,0,0,0)); } }
    .toggle { display:flex; align-items:center; gap:6px; font-size:12px; }

    .btnseg { display:inline-flex; gap:6px; }
    .btnseg .seg { padding:4px 10px; border-radius:8px; border:1px solid #ccc; background:#f7f7f7; cursor:pointer; font-size:12px; }
    .btnseg .seg.active { background:#111; color:#fff; border-color:#111; }

    .sparkline { margin-top:6px; }
    .sparkline text { font-size:10px; fill:#555; }
    .leaflet-tooltip, .leaflet-tooltip .leaflet-tooltip-content, .sparkline { overflow: visible; }

    /* ===== Bottom centered "toast" progress (small popup) ===== */
    #globalCleanBar{
      position: fixed;
      left: 50%;
      bottom: 14px;
      transform: translateX(-50%);
      z-index: 2000;

      width: min(520px, calc(100vw - 28px));
      background: rgba(255,255,255,.96);
      border: 1px solid #e6e6e6;
      border-radius: 14px;
      box-shadow: 0 8px 24px rgba(0,0,0,.12);
      padding: 10px 12px;

      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      display: none;
      opacity: 0;
      transition: opacity 3s ease;
      pointer-events: none;
    }
    #globalCleanBar.show {
      display: block;
      opacity: 1;
      transition: opacity .18s ease;
    }
    #globalCleanBar.fade {
      opacity: 0;
      transition: none;
    }

    #globalCleanBar .gcb-top{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 12px;
      font-size: 12px;
      color: #222;
      margin-bottom: 8px;
      white-space: nowrap;
    }
    #globalCleanBar .gcb-top .left{
      overflow:hidden;
      text-overflow: ellipsis;
    }
    #globalCleanBar .gcb-track{
      height: 8px;
      background: #eee;
      border-radius: 999px;
      overflow: hidden;
    }
    #globalCleanBar .gcb-track > div{
      height: 100%;
      width: 0%;
      background: #111;
      border-radius: 999px;
      transition: width .12s linear;
    }
  </style>
</head>
<body>
  <div class="panel">
    <h1>Florida ZIP Volume Map</h1>

    <div class="row">
      <label>Date:
        <select id="day"></select>
      </label>
      <div class="btnseg" id="rangeBtns">
        <button class="seg" id="btn1w">1W</button>
        <button class="seg" id="btn1m">1M</button>
        <button class="seg" id="btnMax">MAX</button>
      </div>

      <a class="btn" id="btnUploadClean">UPLOAD</a>
    </div>

    <div class="row">
      <input class="input" id="searchZip" placeholder="Search ZIP (prefix or full)" maxlength="5" />
      <a class="btn" id="doSearch">Search</a>
      <a class="btn" id="clearFocus">Clear</a>
    </div>

    <div class="row">
      <label>Threshold highlight:
        <input class="input" style="width:100px" id="threshold" type="number" placeholder=">= value" />
      </label>
      <label class="toggle"><input type="checkbox" id="thresholdOn" /> Enable</label>
    </div>

    <input type="file" id="cleanFilePicker" accept=".csv,.xlsx" style="display:none" />

    <div class="hint">
      Fast load: first loads latest <b>7 days</b>. 1M / MAX loads on demand.
    </div>
  </div>

  <!-- ✅ Small bottom centered toast progress -->
  <div id="globalCleanBar" aria-live="polite">
    <div class="gcb-top">
      <span class="left" id="cleanLabel">Ready</span>
      <span id="cleanPct">0%</span>
    </div>
    <div class="gcb-track">
      <div id="cleanFill"></div>
    </div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <script>
    // ====== Configure your GitHub repository here ======
    const GH_OWNER  = 'BeanSauce-hub';
    const GH_REPO   = 'zipcodeMap';
    const GH_BRANCH = 'main';

    const T  = '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';
    // ===================================================

    // ---------- Global state ----------
    let windowMode = '1W';         // '1W' | '1M' | 'MAX'
    const daily = {};              // { 'YYYY-MM-DD': { zip: value } }
    let daysList = [];             // all available days in repo
    const breaks = {};             // { day: [q20,q40,q60,q80] }
    const loadedDays = new Set();  // which days have been fetched & parsed

    // --- Focus highlight state ---
    let focusedZip = null;
    let focusWired = false;

    // ---------- Utils ----------
    function fmt(n){ return (Math.round((Number(n)||0)*100)/100).toLocaleString(); }
    function normZip(z){
      let s = String(z ?? '').trim();
      if (s.endsWith('.0')) s = s.slice(0,-2);
      s = s.replace(/\D/g,'');
      if (s.length > 5) s = s.slice(0,5);
      return s.padStart(5,'0');
    }
    function parseCsv(text){
      const out = Papa.parse(text, { header: true, skipEmptyLines: true, dynamicTyping: false });
      const rows = out.data.map(r=>{
        const obj = {}; Object.keys(r).forEach(k=>{ obj[k?.trim?.()] = String(r[k] ?? '').trim(); });
        return obj;
      });
      const headers = out.meta.fields || [];
      return { headers, rows };
    }
    function sortDatesAsc(ds){ return ds.slice().sort((a,b)=> a.localeCompare(b)); }

    // UTC date helpers
    function addDaysUTC(iso, n){
      const [y,m,d] = iso.split('-').map(Number);
      const dt = new Date(Date.UTC(y, m-1, d + n));
      return dt.toISOString().slice(0,10);
    }
    function rangeDaysUTC(a,b){
      const out=[]; let cur=a;
      while(true){ out.push(cur); if(cur===b)break; cur=addDaysUTC(cur,1); }
      return out;
    }

    // ---------- Focus styles ----------
    function applyFocusStyles(){
      if (!geoLayer || !focusedZip) return;

      geoLayer.eachLayer(l => {
        const z = getZipFromFeature(l.feature);
        const isTarget = (z === focusedZip);

        if (isTarget) {
          l.setStyle({ opacity: 1, fillOpacity: 0.95, weight: 3, color: '#000' });
          l.bringToFront();

          const el = l.getElement();
          if (el){
            el.classList.add('flash');
            setTimeout(()=> el.classList.remove('flash'), 1800);
          }
        } else {
          l.setStyle({ opacity: 0.20, fillOpacity: 0.12, weight: 0.7, color: '#777' });
        }
      });
    }
    function clearFocus(){
      focusedZip = null;
      if (!geoLayer) return;
      geoLayer.setStyle(styleFeature);
      info.update();
    }

    // ---------- Mini sparkline chart ----------
    function buildSparklineSVG(zip, currentDay) {
      const mode = (typeof windowMode === 'string' ? windowMode : '1W');
      const allDays = sortDatesAsc(Object.keys(daily)); // only loaded days
      if (!allDays.length) return "";

      const endDay = (currentDay && daysList.includes(currentDay)) ? currentDay : (daysList[daysList.length - 1] || allDays[allDays.length - 1]);
      const span = (mode === '1W') ? 7 : (mode === '1M') ? 30 : null;

      let fullDays;
      if (span) {
        const start = addDaysUTC(endDay, -(span - 1));
        fullDays = rangeDaysUTC(start, endDay);
      } else {
        fullDays = rangeDaysUTC(allDays[0], allDays[allDays.length - 1]);
      }

      const vals = fullDays.map(d => {
        const v = daily[d]?.[zip];
        return (v == null || Number.isNaN(v)) ? null : Number(v);
      });

      const valid = vals.filter(v => v != null);
      if (valid.length < 2) return "";

      const minV = 0;
      const maxData = Math.max(...valid, 0);
      const maxV = maxData * 1.05 || 1;

      const W = 300, H = 100;
      const GUTTER_LEFT = 56;
      const PAD_X = 14, PAD_Y = 18;
      const plotX0 = GUTTER_LEFT + PAD_X;
      const plotX1 = W - PAD_X - 6;
      const plotW  = plotX1 - plotX0;

      const xs = fullDays.map((_, i) =>
        plotX0 + (i * plotW / Math.max(1, fullDays.length - 1))
      );
      const yScale = v => H - PAD_Y - ((v - minV) / (maxV - minV)) * (H - 2 * PAD_Y);

      const points = vals.map((v,i) => v==null ? null : ({ x: xs[i], y: yScale(v) }));
      let d = "";
      for (let i=0;i<points.length;i++){
        const p = points[i]; if (!p) continue;
        if (i===0 || !points[i-1]) d += `M ${p.x} ${p.y}`; else d += ` L ${p.x} ${p.y}`;
      }

      const wantLabelIdx = [];
      if (mode === '1W') {
        for (let i=0; i<fullDays.length; i++) wantLabelIdx.push(i);
      } else if (mode === '1M') {
        for (let i=0; i<fullDays.length; i++) {
          const day = parseInt(fullDays[i].slice(8,10), 10);
          if (day === 1 || day % 5 === 0) wantLabelIdx.push(i);
        }
      } else {
        for (let i=0; i<fullDays.length; i++) {
          const day = parseInt(fullDays[i].slice(8,10), 10);
          if (day === 1) wantLabelIdx.push(i);
        }
        const MAX_TICKS = 8;
        if (wantLabelIdx.length > MAX_TICKS) {
          const step = Math.ceil(wantLabelIdx.length / MAX_TICKS);
          const slim = [];
          for (let i=0;i<wantLabelIdx.length;i+=step) slim.push(wantLabelIdx[i]);
          wantLabelIdx.length = 0; wantLabelIdx.push(...slim);
        }
      }

      const fmtTick = (iso) => {
        const m = parseInt(iso.slice(5,7), 10);
        const dd = parseInt(iso.slice(8,10), 10);
        if (dd === 1) return `${m}-1`;
        return `${dd}`;
      };
      const xLabels = wantLabelIdx.map(i =>
        `<text x="${xs[i]}" y="${H-4}" text-anchor="middle" font-size="10" fill="#555">${fmtTick(fullDays[i])}</text>`
      ).join("");

      const minY = yScale(minV), maxY = yScale(maxData);
      const guides = `
        <line x1="${plotX0}" y1="${minY}" x2="${plotX1}" y2="${minY}" stroke="#eee"/>
        <line x1="${plotX0}" y1="${maxY}" x2="${plotX1}" y2="${maxY}" stroke="#eee"/>
        <text x="${GUTTER_LEFT - 6}" y="${maxY + 3}" text-anchor="end" font-size="10"
              style="paint-order: stroke; stroke: #fff; stroke-width: 3px;" fill="#666">${Math.round(maxData)}</text>
        <text x="${GUTTER_LEFT - 6}" y="${minY + 3}" text-anchor="end" font-size="10"
              style="paint-order: stroke; stroke-width: 3px; stroke: #fff;" fill="#666">0</text>
      `;

      return `
        <div class="sparkline">
          <svg width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
            <line x1="${plotX0}" y1="${H - PAD_Y}" x2="${plotX1}" y2="${H - PAD_Y}" stroke="#ccc"/>
            ${guides}
            <path d="${d}" fill="none" stroke="#d62728" stroke-width="2" stroke-linejoin="round" stroke-linecap="round"/>
            ${xLabels}
          </svg>
        </div>
      `;
    }

    function buildTooltipHTML(zip, currentDay) {
      const val = daily[currentDay]?.[zip];
      const valHtml = (val == null || Number.isNaN(val))
        ? '<span style="color:#999">—</span>'
        : `<b style="background:rgba(255,230,150,.6);padding:0 4px;border-radius:4px">${fmt(val)}</b>`;
      const trend = buildSparklineSVG(zip, currentDay);
      return `
        <div><b>ZIP:</b> ${zip}</div>
        <div style="margin-top:4px"><b>${currentDay}</b>: ${valHtml}</div>
        ${trend}
      `;
    }

    // ---------- Map ----------
    const map = L.map('map').setView([27.8, -81.7], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom: 12, attribution: '&copy; OpenStreetMap'}).addTo(map);
    map.zoomControl.setPosition('bottomleft');

    const info = L.control({ position: 'topright' });
    info.onAdd = function(){ this._div = L.DomUtil.create('div','info'); this.update(); return this._div; };
    info.update = function(props){
      if (!props) { this._div.innerHTML = ''; return; }
      const zip = props.ZCTA5CE10 || props.ZCTA5CE || props.zip || '';
      const cur = daySel.value;
      this._div.innerHTML = buildTooltipHTML(zip, cur);
    };
    info.addTo(map);

    let geoLayer;
    const layerByZip = {};
    const daySel = document.getElementById('day');
    const searchInput = document.getElementById('searchZip');
    const doSearch = document.getElementById('doSearch');
    const clearBtn = document.getElementById('clearFocus');

    const thresholdOn = document.getElementById('thresholdOn');
    const thresholdInput = document.getElementById('threshold');

    function getZipFromFeature(f){ return (f.properties.ZCTA5CE10 || f.properties.ZCTA5CE || f.properties.zip || '').toString().padStart(5,'0'); }

    function getColor(d, b) {
      if (d == null) return '#f2f2f2';
      if (d <= b[0]) return '#ffffcc';
      if (d <= b[1]) return '#ffeda0';
      if (d <= b[2]) return '#feb24c';
      if (d <= b[3]) return '#fd8d3c';
      return '#e31a1c';
    }
    function overThreshold(val){
      if (!thresholdOn.checked) return false;
      const t = Number(thresholdInput.value);
      if (!isFinite(t)) return false;
      return (Number(val)||0) >= t;
    }

    function styleFeature(feature){
      const z = getZipFromFeature(feature);
      const d = daySel.value;
      const val = (daily[d] && daily[d][z] != null) ? daily[d][z] : null;
      const base = {weight:.7, opacity:1, color:'#555', fillOpacity:.82, fillColor:getColor(val, breaks[d]||[0,0,0,0])};
      if (overThreshold(val)) { base.color='#e31a1c'; base.weight=2; }
      return base;
    }
    function highlightFeature(e){
      const layer = e.target; layer.setStyle({weight:2.5,color:'#000',fillOpacity:.9}); layer.bringToFront();
      const z=getZipFromFeature(layer.feature);
      info.update({ ZCTA5CE10:z });
    }
    function resetHighlight(e){
      geoLayer.resetStyle(e.target);
      info.update();
      if (focusedZip) applyFocusStyles();
    }
    function onEachFeature(feature,layer){
      const z = getZipFromFeature(feature);
      layerByZip[z] = layer;
      layer.on({mouseover:highlightFeature, mouseout:resetHighlight, click:highlightFeature});
      layer.bindTooltip(() => buildTooltipHTML(z, daySel.value), { sticky: true });
    }

    function computeBreaks(values){
      const vals = values.filter(v=>v>0 && isFinite(v)).sort((a,b)=>a-b);
      if (!vals.length) return [0,0,0,0];
      const q = p => vals[Math.floor(p*(vals.length-1))];
      return [q(.2), q(.4), q(.6), q(.8)];
    }
    function updateBreaksFor(day){
      const vals = Object.values(daily[day]||{}).map(v=>+v||0);
      breaks[day] = computeBreaks(vals);
    }
    function refreshMap(){
      const d = daySel.value;
      if (!d || !geoLayer) return;
      updateBreaksFor(d);
      geoLayer.setStyle(styleFeature);
      legend.update();
      info.update(info._lastProps);
      if (focusedZip) applyFocusStyles();
    }

    const legend=L.control({position:'bottomright'});
    legend.onAdd=function(map){ this._div=L.DomUtil.create('div','legend'); this.update(); return this._div; };
    legend.update=function(){
      const d = daySel.value; const b = breaks[d]||[0,0,0,0];
      const colors = ['#ffffcc','#ffeda0','#feb24c','#fd8d3c','#e31a1c'];
      const labels = [
        `${fmt(0)} – ${fmt(b[0])}`,
        `${fmt(b[0])} – ${fmt(b[1])}`,
        `${fmt(b[1])} – ${fmt(b[2])}`,
        `${fmt(b[2])} – ${fmt(b[3])}`,
        `>${fmt(b[3])}`
      ];
      let html = '<b>Color Legend</b><br/>';
      for (let i=0; i<labels.length; i++) {
        html += `<i style="background:${colors[i]};width:14px;height:14px;display:inline-block;margin-right:6px;border:1px solid #999"></i>${labels[i]}<br/>`;
      }
      this._div.innerHTML = html;
    };
    legend.addTo(map);

    const _origInfoUpdate = info.update.bind(info);
    info.update = function(props){ this._lastProps = props || this._lastProps; _origInfoUpdate(this._lastProps); };

    (async function autoLoadLocalGeo(){
      try {
        const r = await fetch('./fl_florida_zip_codes_geo.min.json', {cache:'no-store'});
        if (!r.ok) throw new Error('HTTP '+r.status);
        const gj = await r.json();
        renderGeo(gj);
      } catch (e) { console.warn('Auto-loading local GeoJSON failed:', e); }
    })();
    function renderGeo(geojson){
      if (geoLayer) map.removeLayer(geoLayer);
      geoLayer = L.geoJSON(geojson, { style: styleFeature, onEachFeature: onEachFeature }).addTo(map);
      map.fitBounds(geoLayer.getBounds());

      if (!focusWired){
        focusWired = true;
        map.on('click', (e) => {
          const t = e.originalEvent?.target;
          const clickedOnPath = t && (t.tagName === 'PATH' || t.tagName === 'path');
          if (!clickedOnPath) clearFocus();
        });
      }

      refreshMap();
    }

    async function fetchCsvDatesFromGitHub() {
      const api = `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/git/trees/${GH_BRANCH}?recursive=1`;
      const r = await fetch(api, { cache: 'no-store' });
      if (!r.ok) throw new Error(`GitHub API ${r.status}`);
      const data = await r.json();
      const dates = (data.tree || [])
        .filter(n => n.type === 'blob' && /^data\/\d{4}-\d{2}-\d{2}\.csv$/i.test(n.path))
        .map(n => n.path.replace(/^data\//, '').replace(/\.csv$/i, ''))
        .sort((a,b)=> a.localeCompare(b));
      return dates;
    }

    async function fetchDayCsv(dayISO){
      if (loadedDays.has(dayISO)) return;
      const r = await fetch(`./data/${dayISO}.csv?ts=` + Date.now(), {cache:'no-store'});
      if (!r.ok) throw new Error(`Failed to read data/${dayISO}.csv: ${r.status}`);
      const text = await r.text();
      const { headers, rows } = parseCsv(text);
      const lowerHeaders = headers.map(h=>h?.trim?.().toLowerCase());

      let zipKey=null, valKey=null;
      for (const a of ['zipcodes','zip','zipcode','zip_code']){
        const idx = lowerHeaders.indexOf(a);
        if (idx!==-1){ zipKey = headers[idx]; break; }
      }
      for (const a of ['quantity','pred_quantity','数量','货量']){
        const idx = lowerHeaders.indexOf(a);
        if (idx!==-1){ valKey = headers[idx]; break; }
      }
      if (!zipKey || !valKey) throw new Error("CSV missing ZIP or quantity column");

      daily[dayISO] = {};
      rows.forEach(r=>{
        const z = normZip(r[zipKey]);
        const v = Number(String(r[valKey]).replace(/,/g,'')) || 0;
        if (z && z!=='00000') daily[dayISO][z] = v;
      });

      loadedDays.add(dayISO);
    }

    async function ensureDaysLoaded(dayArray){
      const need = dayArray.filter(d => !loadedDays.has(d));
      if (!need.length) return;
      for (const d of need){
        await fetchDayCsv(d);
      }
    }

    async function ensureWindowData(){
      if (!daysList.length) return;
      const endDay = daySel.value || daysList[daysList.length-1];
      if (!endDay) return;

      if (windowMode === 'MAX'){
        await ensureDaysLoaded(daysList);
        return;
      }

      const span = (windowMode === '1M') ? 30 : 7;
      const start = addDaysUTC(endDay, -(span-1));
      const want = rangeDaysUTC(start, endDay).filter(d => daysList.includes(d));
      await ensureDaysLoaded(want);
    }

    async function loadInitialFast7(){
      try{
        daySel.disabled = true;

        const list = await fetchCsvDatesFromGitHub();
        if (!list.length){ alert('No YYYY-MM-DD.csv files found in data/ directory'); return; }

        daysList = list.slice();
        renderDayOptions();

        const latest7 = daysList.slice(-7);
        for (const d of latest7){
          await fetchDayCsv(d);
        }

        refreshMap();
      }catch(e){
        console.error(e);
        alert('Failed to load data from repository: ' + e.message);
      }finally{
        daySel.disabled = false;
      }
    }

    function renderDayOptions(){
      const sel = daySel;
      const cur = sel.value;
      sel.innerHTML = '';
      daysList.forEach(d=>{
        const opt = document.createElement('option');
        opt.value = d; opt.textContent = d;
        sel.appendChild(opt);
      });
      if (daysList.length){
        sel.value = daysList.includes(cur) ? cur : daysList[daysList.length-1];
      }
    }

    function focusZip(query){
      if (!geoLayer) { alert('Please load the map first.'); return; }
      const q = (query||'').trim(); if (!q) return;
      const target = Object.keys(layerByZip).find(z => z.startsWith(q));
      if (!target) { alert('No matching ZIP found.'); return; }

      focusedZip = target;
      applyFocusStyles();

      const layer = layerByZip[target];
      map.fitBounds(layer.getBounds(), {maxZoom: 10});
      layer.openTooltip();
    }

    // =========================
    // ✅ Cleaner UI wiring (toast)
    // =========================
    const btnUploadClean = document.getElementById('btnUploadClean');
    const cleanPicker = document.getElementById('cleanFilePicker');
    const globalCleanBar = document.getElementById('globalCleanBar');
    const cleanFill = document.getElementById('cleanFill');
    const cleanLabel = document.getElementById('cleanLabel');
    const cleanPct = document.getElementById('cleanPct');

    let hideTimer = null;
    let fadeRAF = null;

    function showCleanToast(){
      if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
      if (fadeRAF) { cancelAnimationFrame(fadeRAF); fadeRAF = null; }

      globalCleanBar.classList.remove('fade');
      globalCleanBar.classList.add('show');
      globalCleanBar.style.display = 'block';

      void globalCleanBar.offsetWidth;
      globalCleanBar.style.opacity = '1';
    }

    function fadeOutCleanToastLinear(durationMs = 3000){
      if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
      if (fadeRAF) { cancelAnimationFrame(fadeRAF); fadeRAF = null; }

      globalCleanBar.classList.remove('show');
      globalCleanBar.classList.add('fade');

      globalCleanBar.style.display = 'block';
      globalCleanBar.style.opacity = '1';

      const t0 = performance.now();
      const startOpacity = 1;
      const endOpacity = 0;

      const step = (now) => {
        const t = (now - t0) / durationMs;
        const clamped = Math.min(1, Math.max(0, t));
        const cur = startOpacity + (endOpacity - startOpacity) * clamped;
        globalCleanBar.style.opacity = String(cur);

        if (clamped < 1) {
          fadeRAF = requestAnimationFrame(step);
        } else {
          fadeRAF = null;
          globalCleanBar.style.display = 'none';
          globalCleanBar.classList.remove('fade');
          globalCleanBar.style.opacity = '';
        }
      };

      fadeRAF = requestAnimationFrame(step);
    }

    function fadeOutCleanToast(){
      fadeOutCleanToastLinear(3000);
    }

    function forceResetCleanProgress(){
      showCleanToast();
      cleanLabel.textContent = 'Working…';
      cleanPct.textContent = '0%';

      cleanFill.style.transition = 'none';
      cleanFill.style.width = '0%';
      void cleanFill.offsetWidth;
      cleanFill.style.transition = 'width .12s linear';
    }

    function setProgress(pct, label){
      const p = Math.max(0, Math.min(100, Math.round(pct)));
      cleanFill.style.width = p + '%';
      cleanPct.textContent = p + '%';
      if (label != null) cleanLabel.textContent = label;
    }

    // =========================
    // ✅ (NEW) Upload pipeline: XLSX -> daily zip counts -> write /data/*.csv to GitHub
    // =========================

    function isEmptyRow(values){
      if (!values) return true;
      for (const v of values){
        if (v == null) continue;
        if (typeof v === 'string' && v.trim() === '') continue;
        return false;
      }
      return true;
    }

    function findColumnIndex(headers, candidates){
      const norm = (s)=> String(s ?? '').trim();
      const lower = (s)=> norm(s).toLowerCase();
      const hs = headers.map(h=>({raw:h, low:lower(h)}));
      for (const c of candidates){
        const cl = lower(c);
        const idx = hs.findIndex(x=>x.low === cl);
        if (idx !== -1) return idx;
      }
      // contains fallback
      for (const c of candidates){
        const cl = lower(c);
        const idx = hs.findIndex(x=>x.low.includes(cl));
        if (idx !== -1) return idx;
      }
      return -1;
    }

    // parse "中心签入时间": "MM/DD/YYYY HH:MM:SS" or "MM/DD/YYYY HH:MM"
    function parseCenterTimeToISODate(s){
      const str = String(s ?? '').trim();
      if (!str) return null;
      const m = str.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
      if (!m) return null;
      const mm = String(m[1]).padStart(2,'0');
      const dd = String(m[2]).padStart(2,'0');
      const yyyy = m[3];
      return `${yyyy}-${mm}-${dd}`; // date only (like Python dt.date)
    }

    function toBase64Utf8(text){
      // base64 for UTF-8 string
      const utf8 = new TextEncoder().encode(text);
      let bin = '';
      utf8.forEach(b => bin += String.fromCharCode(b));
      return btoa(bin);
    }

    async function ghRequest(path, options = {}){
      if (!T || T === 'PASTE_YOUR_TOKEN_HERE'){
        throw new Error('GitHub token missing. Please set T in index.html');
      }
      const url = `https://api.github.com${path}`;
      const headers = {
        'Accept': 'application/vnd.github+json',
        'Authorization': `Bearer ${T}`,
        'X-GitHub-Api-Version': '2022-11-28',
        ...(options.headers || {})
      };
      const res = await fetch(url, { ...options, headers });
      const text = await res.text();
      let json = null;
      try { json = text ? JSON.parse(text) : null; } catch { /* ignore */ }
      if (!res.ok){
        const msg = (json && (json.message || json.error)) ? (json.message || json.error) : text;
        throw new Error(`GitHub API ${res.status}: ${msg}`);
      }
      return json;
    }

    async function getExistingFileSha(repoPath){
      // GET /repos/{owner}/{repo}/contents/{path}?ref=branch
      try{
        const j = await ghRequest(`/repos/${GH_OWNER}/${GH_REPO}/contents/${encodeURIComponent(repoPath)}?ref=${encodeURIComponent(GH_BRANCH)}`, {
          method: 'GET'
        });
        // file object has sha
        return j && j.sha ? j.sha : null;
      }catch(e){
        // if 404 -> no file
        if (String(e.message || '').includes('404')) return null;
        // GitHub sometimes returns 404 in msg; be defensive:
        if (String(e.message || '').includes('Not Found')) return null;
        throw e;
      }
    }

    async function putFileToGitHub(repoPath, contentText, commitMessage){
      const sha = await getExistingFileSha(repoPath);
      const body = {
        message: commitMessage,
        content: toBase64Utf8(contentText),
        branch: GH_BRANCH
      };
      if (sha) body.sha = sha;

      await ghRequest(`/repos/${GH_OWNER}/${GH_REPO}/contents/${encodeURIComponent(repoPath)}`, {
        method: 'PUT',
        body: JSON.stringify(body)
      });
    }

    function buildDailyZipCountsFromXlsx(array2d){
      // array2d: [ [header...], [row...], ... ]
      if (!array2d || array2d.length < 2) throw new Error('Excel seems empty.');

      const headers = (array2d[0] || []).map(h => String(h ?? '').trim());
      const zipIdx = findColumnIndex(headers, ['邮编', 'zipcode', 'zip', 'zip_code', 'zipcodes']);
      const timeIdx = findColumnIndex(headers, ['中心签入时间', 'center check-in time', 'checkin', 'check-in']);

      if (zipIdx === -1) throw new Error('ZIP column not found (expected: 邮编 / zipcode / zip).');
      if (timeIdx === -1) throw new Error('Time column not found (expected: 中心签入时间).');

      const counts = new Map(); // date -> Map(zip -> count)

      let emptyStreak = 0;
      const TAIL_BREAK = 200;

      for (let i=1; i<array2d.length; i++){
        const row = array2d[i];
        if (isEmptyRow(row)){
          emptyStreak++;
          if (emptyStreak >= TAIL_BREAK) break;
          continue;
        }
        emptyStreak = 0;

        const zipRaw = row[zipIdx];
        const timeRaw = row[timeIdx];

        const dateISO = parseCenterTimeToISODate(timeRaw);
        if (!dateISO) continue;

        const zip = String(zipRaw ?? '').trim();
        if (!zip) continue;

        if (!counts.has(dateISO)) counts.set(dateISO, new Map());
        const m = counts.get(dateISO);
        m.set(zip, (m.get(zip) || 0) + 1);
      }

      if (!counts.size) throw new Error('No valid rows after parsing dates.');

      return counts;
    }

    function buildCsvForOneDay(zipCountMap){
      // output columns compatible with your loader: zipcodes + quantity
      const rows = [];
      for (const [zip, qty] of zipCountMap.entries()){
        // keep original string but normalize to 5 digits for consistency
        const z = normZip(zip);
        if (!z || z === '00000') continue;
        rows.push([z, qty]);
      }
      rows.sort((a,b)=> a[0].localeCompare(b[0]));
      let csv = 'zipcodes,quantity\n';
      for (const [z, q] of rows){
        csv += `${z},${q}\n`;
      }
      return csv;
    }

    async function refreshDaysListFromRepo(){
      const list = await fetchCsvDatesFromGitHub();
      daysList = list.slice();
      renderDayOptions();
    }

    btnUploadClean.addEventListener('click', ()=> cleanPicker.click());

    cleanPicker.addEventListener('change', async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;

      try{
        forceResetCleanProgress();
        setProgress(2, 'Reading file…');

        const ext = (f.name.split('.').pop() || '').toLowerCase();

        let dailyCounts = null;

        if (ext === 'xlsx'){
          const ab = await f.arrayBuffer();
          setProgress(10, 'Parsing XLSX…');
          const wb = XLSX.read(ab, { type: 'array' });
          const ws = wb.Sheets[wb.SheetNames[0]];
          const array2d = XLSX.utils.sheet_to_json(ws, { header: 1, raw: false, defval: '' });
          setProgress(18, 'Building daily ZIP counts…');
          dailyCounts = buildDailyZipCountsFromXlsx(array2d);
        } else if (ext === 'csv'){
          const text = await f.text();
          setProgress(10, 'Parsing CSV…');
          const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
          const headers = parsed.meta.fields || [];

          const zipKey = (()=>{
            const lowers = headers.map(h=>String(h||'').trim().toLowerCase());
            const idx = lowers.indexOf('邮编') !== -1 ? lowers.indexOf('邮编')
              : (lowers.indexOf('zipcode') !== -1 ? lowers.indexOf('zipcode')
              : (lowers.indexOf('zip') !== -1 ? lowers.indexOf('zip') : -1));
            return idx === -1 ? null : headers[idx];
          })();

          const timeKey = (()=>{
            const lowers = headers.map(h=>String(h||'').trim().toLowerCase());
            const idx = lowers.indexOf('中心签入时间') !== -1 ? lowers.indexOf('中心签入时间') : -1;
            return idx === -1 ? null : headers[idx];
          })();

          if (!zipKey) throw new Error('CSV missing ZIP column (expected: 邮编/zipcode/zip).');
          if (!timeKey) throw new Error('CSV missing time column (expected: 中心签入时间).');

          dailyCounts = new Map();
          setProgress(18, 'Building daily ZIP counts…');

          let emptyStreak = 0;
          const TAIL_BREAK = 200;
          for (const r of parsed.data){
            const rowVals = Object.values(r);
            if (isEmptyRow(rowVals)){
              emptyStreak++;
              if (emptyStreak >= TAIL_BREAK) break;
              continue;
            }
            emptyStreak = 0;

            const dateISO = parseCenterTimeToISODate(r[timeKey]);
            if (!dateISO) continue;
            const zip = String(r[zipKey] ?? '').trim();
            if (!zip) continue;

            if (!dailyCounts.has(dateISO)) dailyCounts.set(dateISO, new Map());
            const m = dailyCounts.get(dateISO);
            m.set(zip, (m.get(zip) || 0) + 1);
          }

          if (!dailyCounts.size) throw new Error('No valid rows after parsing CSV dates.');
        } else {
          throw new Error('Unsupported file type. Please upload .xlsx or .csv');
        }

        const dates = Array.from(dailyCounts.keys()).sort((a,b)=>a.localeCompare(b));
        setProgress(25, `Uploading ${dates.length} file(s)…`);

        // upload sequentially (safe + simplest)
        const total = dates.length;
        let done = 0;

        for (const day of dates){
          const csv = buildCsvForOneDay(dailyCounts.get(day));
          const repoPath = `data/${day}.csv`;
          const msg = `Upload daily ZIP counts for ${day}`;
          await putFileToGitHub(repoPath, csv, msg);

          done++;
          const pct = 25 + (done/total)*70; // 25%~95%
          setProgress(pct, `Uploaded ${done}/${total} • ${day}`);
        }

        setProgress(98, 'Refreshing file list…');
        await refreshDaysListFromRepo();

        // Optional: clear caches so a later switch reloads
        loadedDays.clear();
        // NOTE: Pages deployment may lag; your site ./data may not reflect immediately.
        setProgress(100, 'Done • GitHub updated (Pages may take a moment)');
        fadeOutCleanToast();

      }catch(err){
        console.error(err);
        setProgress(100, 'Failed');
        alert(err?.message || String(err));
        fadeOutCleanToast();
      }finally{
        cleanPicker.value = '';
      }
    });

    // Interactions
    doSearch.addEventListener('click', ()=> focusZip(searchInput.value));
    searchInput.addEventListener('keydown', e=>{ if (e.key==='Enter') focusZip(searchInput.value); });
    clearBtn.addEventListener('click', ()=> clearFocus());

    daySel.addEventListener('change', async ()=>{ await ensureWindowData(); refreshMap(); });
    thresholdOn.addEventListener('change', refreshMap);
    thresholdInput.addEventListener('change', refreshMap);

    const btn1w = document.getElementById('btn1w');
    const btn1m = document.getElementById('btn1m');
    const btnMax= document.getElementById('btnMax');

    function syncRangeButtons(){
      btn1w.classList.toggle('active', windowMode==='1W');
      btn1m.classList.toggle('active', windowMode==='1M');
      btnMax.classList.toggle('active', windowMode==='MAX');
    }
    btn1w.addEventListener('click', async ()=>{ windowMode='1W'; syncRangeButtons(); await ensureWindowData(); refreshMap(); });
    btn1m.addEventListener('click', async ()=>{ windowMode='1M'; syncRangeButtons(); await ensureWindowData(); refreshMap(); });
    btnMax.addEventListener('click', async ()=>{ windowMode='MAX'; syncRangeButtons(); await ensureWindowData(); refreshMap(); });

    document.addEventListener('DOMContentLoaded', async () => {
      syncRangeButtons();
      await loadInitialFast7().catch(e => console.warn('Initial load failed:', e));
    });
  </script>
</body>
</html>
